\chapter{Experiments}
\label{chap:Experiments}

Comparison of both implementations is an important part of the whole thesis
and for objective results multiple tests were needed.

I choose two different problems mentioned in the \cref{chap:Problems}.
First of them is a problem of maximum edge weight between given vertices with
interval update (described in section \ref{sec:maximum_edge_weight}), which uses
Top trees directly and aims to work in time $\O(\log N)$ per operation. Second
problem is an edge 2-connectivity (described in section \ref{sec:edge_2_connectivity}),
which uses Top trees ``under the hood'' and aims to work in time $\O(\log^4 N)$
per operation. Both problems uses Top trees in different ways.

Another necessary condition of good comparison is to have various input data. In
our case of investigating Top trees behavior with given problems input data
consist of two things:
\begin{itemize}
\item Size and type of the underlying graph (number of edges, degrees of vertices)
\item Strategy of data structure usage (portion of affected edges, ration of
operation types, \dots)
\end{itemize}

\section{Experiments strategy}

Common scenario for all experiments was introduced. Each experiment was done
for both implementations with the same input data and with increasing input
size:

\begin{itemize}
\item Choose graph size (number of vertices and edges)
\item For each chosen graph size choose 10 random seeds to generate input data
and sequence of operations
\item For every implementation and every seed run test and measure elapsed time
\item Compute average elapsed time and standard deviation for each input size
\end{itemize}

Python wrapper was used to generate random seeds and to execute testing utilities.
Testing utilities written in \Cpp{} firstly generates all the input data and
sequence of operations, initializes data structures and then began to measure
time and execute the operations.

This procedure was chosen to minimize influence of test functions and to measure
only the time used by Top trees operations.

\vfill\eject %% PRINTHACK

\section{Maximum edge weight experiment}
\label{sec:experiment_maximum_edge_weight}

This problem was described in section \ref{sec:maximum_edge_weight} and it
operates directly on the underlying tree.

For given size $N$ of the tree and number of operations we randomly generated
initial tree with $N$ edges and $N+1$ vertices and then list of operations
(every operation with the same chance).

Number of edges during execution was maintained between $N$ and $\frac{7}{10}N$
to maintain the input size.

Possible operations are:

\begin{itemize}
\item Add edge -- Choose random two vertices and execute \Link{} operation
(when we choose two vertices in the same top tree the Top trees structure should
return an error).
\item Remove edge -- If there are at least $\frac{7}{10}N$ edges choose random
edge from list of edges and execute \Cut{} operation (we will maintain array of
added edges so every remove operation should be successful), otherwise skip this
operation.
\item Add weight on path -- Execute \Expose{} operation and modify content of
the returned root cluster.
\item Get weight on path -- Execute \Expose{} operation and read content of the
returned root cluster.
\end{itemize}

Every operation executes $\O(1)$ top trees operations and it should take time
$\O(\log N)$ (where $N$ is maximal number of edges).

When initial edges and list of operations were created both implementations were
tested. Firstly each implementation was initialized from the initial edges and
time of this initialization was measured. Secondly all the operations were
executed and running time of all operations was measured.

Results from this experiment follows in the section
\ref{sec:results_maximum_edge_weight}.


\section{Edge 2-connectivity experiment}
\label{sec:experiment_edge_2_connectivity}

This problem was described in section \ref{sec:edge_2_connectivity} and it uses
top trees as helper data structure for more complex operations. The problem
should operate in time complexity $\O(\log^4 N)$ where $N$ is a number of edges
in the underlying graph.

\todo{Describe edge 2-connectivity experiment}
