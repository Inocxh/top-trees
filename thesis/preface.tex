\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Main target of this thesis is to provide two different {\I Top Trees}
implementations and to compare them in different situations. Both implementation
were written from scratch in \Cpp{} to provide comparable results.

{\I Top Trees} are not so well known data structure which could be used to
maintain information of some dynamically updated collection of trees. User of
this data structure defines four basic operations, which are used internally
when Top Trees structure is changing, and the structure updates internally
stored information when there occurs some cutting or joining on underlying
trees.

This data structure could be used for example to dynamically maintain diameter,
center or median (minimizing weighted distance from all other vertices) of given
tree in time $\O(\log N)$ (where $N$ denotes the number of vertices).

Because it is essential to understand how the Top Trees structure works, some
basic principles of the Top Trees structure are introduced in the
\Cref{chap:TopTrees} and some basic principles of Topology trees used in one of
the implementations are introduced in the \Cref{chap:TopologyTrees}. Some
examples of problems, whose could Top Trees handle quickly, are listed in
\Cref{chap:Problems} of this thesis.

Basic usage of both implementations and some technical details are the contents
of the \Cref{chap:Implementation}, \Cref{chap:ImplementationSelfAdjusting} and
\Cref{chap:ImplementationTopology} describes details of both implementations.

First implementation of the Top Trees structure is based on article {\I
Self-Adjusting Top Trees} \cite{SelfAdjustingTT} by Tarjan and Werneck. This
implementation promises quick amortized time per operation (with small
constant), but it does not guarantee these times in worst case. This
implementation is described in \Cref{chap:ImplementationSelfAdjusting} of this thesis.

Second implementation is based on article {\I Maintaining Information in Fully-
Dynamic Trees with Top Trees} \cite{TopTrees} by Alstrup, Holm, Lichtenberg and
Thorup and uses Topology trees introduced by Frederickson in
\cite{DSforDynamicallyMaintainingRootedTrees}. This implementation promises time
$\O(\log N)$ in worst-case but with much larger multiplicative constant. This
implementation is described in \Cref{chap:ImplementationTopology} of this thesis.

To compare both implementations it was necessary to perform some experiments on
different problems on different trees with different sizes. Experiments were
performed on problem of {\I maximum edge weight in tree with interval updates}
(described in section \ref{sec:maximum_edge_weight}) and on problem of {\I edge
2-connectivity} (described in section \ref{sec:edge_2_connectivity}. Details of
these experiments and their setup are described in \Cref{chap:Experiments}.

We expected that the first implementations would have smaller multiplicative
constant than the second one. This expectation turned out to be right and
multiplicative constant for both implementations was measured in
\Cref{chap:Results} together with some results for turning out unnecessary
updates during some operation in the second implementation.
