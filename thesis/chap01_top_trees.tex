\chapter{Top Trees}
\label{chap:TopTrees}

Top Trees are data structure intended to maintain informations of underlying
dynamically updated forest. They were introduced by Alstrup, Holm, Lichtenberg
and Thorup in {\I Minimizing Diamaters of Dynamic Trees}
\cite{MinimizingDiamatersOfDynamicTrees} in 1997 as variant of the Topology
Trees and they were extended by the same authors in
{\I Maintaining Information in Fully-Dynamic Trees with Top Trees} \cite{TopTrees} in 2003.

\section{Definition}

{\I Top Trees structure} acts as driver for underlying forest. It represents
underlying trees as collection of generalized edges called {\I clusters}. Each
{\I Cluster} represents some subtree in the underlying forest. Only
some of them called {\I root clusters} (which represents whole trees of the
underlying forest) could be directly accessed by the user.

User defines format of the data stored in these clusters and four basic
functions {\sc Create}, {\sc Destroy}, {\sc Join} and {\sc Split} used to
manipulate with clusters data. Above that user could define fifth function
{\sc Choose} which is needed for some use cases but it is not needed for basic
usage.

Then user controls the Top Trees structure by using operations $\cut{u,v}$,
$\link{u,v}$ and $\expose{u,v}$. Last of them
makes cluster representing the path between vertices $u$ and $v$ a root cluster
(because root clusters are the only clusters of the top tree, whose could be
accessed by the user). The Top Trees structure dynamically updates stored data
in clusters by using user defined functions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Clusters}

As has been said {\I Clusters} are generalized edges. Each cluster has two
{\I boundary vertices} and represents part of the underlying forest between
these vertices. We denote two clusters as {\I connected} if they are edge
disjoint and they share one boundary vertex.

A {\I Clusterization} is division of the underlying forest into clusters such
that each edge is in exactly one cluster. As we mentioned above {\I roots
clusters} are the ones that represents whole trees in the underlying forest
(all edges of their underlying tree are contracted inside and there are no
outgoing edges -- this means that in a clusterization both their boundary
vertices are not connected with any other cluster).

Another special clusters are {\I leaf clusters}. We denote a cluster as a
{\I leaf cluster} in some clusterization if only one of its boundary vertices is
connected to another cluster.

Clusters in the Top Trees structure are organized into binary trees (called
{\I top trees}) where each leaf represents one edge of the underlying forest and
each inner vertex represents contraction of its children. More about this
structure will be discussed later in the {\I Cluster model} subsection. Before
that we need to introduce types of clusters.

There are three types of clusters:
\begin{itemize}

\item {\bf Base cluster} -- represents one edge of the underlying forest (and
each edge of the underlying forest has exactly one base cluster, it is 1:1 mapping),
boundary vertices are endpoints of the edge.

This cluster could appear only as leaf in the Top Trees structure.

\item {\bf Rake cluster} -- represents one way how to contract two clusters
with one common boundary vertex. Let's have two clusters $C_1(u,v)$ and
$C_2(v,w)$ next to each other around common boundary vertex $v$ (and let the
$C_1$ be the left one of them in some topological order given for example by
indices of the edges or by some planar embedding).

If the left cluster ($C_1$) is a leaf cluster then we can construct {\I left
rake cluster} by {\I raking} the left cluster ($C_1$) on the right one ($C_2$).
The resulting cluster would have the same boundary vertices as the cluster $C_2$.

If the right cluster ($C_2$) is a leaf cluster then we can, similarly to the
previous case, construct {\I right rake cluster} by {\I raking} the right
cluster ($C_2$) on the left one ($C_1$). The resulting cluster would have the
same boundary vertices as the cluster $C_1$.

\todo{Image of rake cluster}

\item{\bf Compress cluster} -- represents other contraction of the two clusters
with one common boundary vertex $v$ into one cluster by attaching first cluster
after the other. Right before compressing the common vertex $v$ must have degree
(number of incident clusters) exactly two. If there are other clusters attached
to the same common boundary vertex they must be firstly {\I raked} onto one of
the compressed clusters.

If boundary vertices of the cluster $C_1$ were $(u,v)$ and boundary vertices
of the cluster $C_2$ were $(v,w)$, the cluster $C=compress(C_1,C_2)$ would have
boundary vertices $(u,w)$ (and we will call it {\I compress cluster
of vertex $v$} and the operation {\I compressing around vertex $v$}).
This cluster also in some way represents the vertex $v$ and we will use it as
{\I handle} of this vertex.

\todo{Image of compress cluster}

\end{itemize}

\subsection{Clusters model}

Clusters in the Top Trees structure are organized into binary trees. Leaves of
these trees (Base clusters) represent edges of the underlying trees and each
inner vertex represents contraction of two child clusters into one.

Compress and rake clusters have each of them two children, base clusters are
childless. Each cluster represent subtree of the underlying forest. By
combination of clusters we could represent each underlying tree as one {\I root
cluster}. This whole binary tree of cluster contractions leading to the one root
cluster is called {\I top tree}.

Compress clusters are used to represent paths in the underlying tree -- each
path could be compressed into one {\I compress tree} consisting only of compress
clusters. If there are branches separating from this path, they are firstly
recursively represented as single clusters ({\I rake trees}) and then they are
{\I raked onto} clusters in the path.

Because there are $M$ base clusters for an underlying tree with $M$ edges and
each inner vertex of the corresponding top tree joins two adjacent clusters into
one, there will be $M-1$ inner clusters for representing this underlying tree.

Underlying tree could have (and usually have) many different divisions into
paths and so the underlying tree have many different representations. Crucial
part of the top trees structure is to maintain this representation in some nice
form during updates.

\subsection{Extended clusters model}

Tarjan and Werneck in \cite{SelfAdjustingTT} suggested that in some cases it may
be useful to modify structure of the clusters and they introduced
{\I foster children} for {\I compress clusters}. In their suggestion a compress
cluster could have up to four descendants -- two normal children and up to two
foster children.

Normal children of a compress cluster are clusters from the compressed path and
foster children are clusters originating from the separating branches. In normal
cluster model they would be raked onto clusters from path and the path would be
compression of these rake clusters.

In this extended model the clusters originating from the separating branches are
firstly combined in so called {\I rake trees} -- there are maximally two rake
trees around each path vertex, one of them is raked from branches on one side of
the path and the second one is raked from branches on the other side of the
path. And these rake trees are connected as left and right foster child of the
compress cluster constructed from this part of the path.

\todo{Image of rake trees around path}

During computation ({\sc Join} and {\sc Split} operations) there is need to use
virtual rake clusters, but it is only $\O(1)$ time complexity per one compress
cluster. We will discuss it later in the first implementation for which this
extended model is used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{User defined functions}

There are four basic function to manipulate the clusters data which have to
be implemented by users of the Top Trees structure. Then user uses public Top
Trees structure operations and these user functions are used internally when
constructing, destroying or reorganizing clusters.

If user wants to use the {\I Search} operation, he has to implement fifth user
function {\I Choose} to traverse around the path by choosing children.

Examples of the functions and related problems are given in the \Cref{chap:Problems}.

\subsection{Create}

This function is called when new base cluster is created. It gets reference to
the underlying edge and to the newly created base cluster, populates base
cluster's data based on the underlying edge and runs other user defined
operations according to logic of given problem.

\subsection{Destroy}

Opposite of the Create function. This function is called just before deleting
base cluster. It gets reference to the underlying edge and to the base cluster
which would be destroyed and it could perform some end-of-life operations (like
saving computed data from the cluster).

\subsection{Join}

This function is called during contraction of two clusters into one (compress or
rake) cluster. In the general view it should populate parent cluster with the
data aggregated from contracted child clusters or perform other join-related
operations according to logic of given problem.

It gets a references to both of the contracted clusters and to the newly created
parent cluster with information about their boundary vertices. From boundary
vertices of the parent and both children can be clearly determined if it is
compress or rake cluster (and which one of the children in rake cluster is raked
onto the another one) -- user may or may not use this information according to
the logic of given problem.

\subsection{Split}

Opposite of the Join function. It is called just before removing connection
among parent cluster and its children. This function gets reference to the
parent cluster and both of its children with information about their boundary
vertices. It should distribute data from the parent into children -- notice that
no data could be stored in the parent cluster after the Split operation (because
the parent cluster is deleted after this operation).

The Join and Split operations are frequently called during reorganization of the
Top trees structure -- common pattern is to Split everything around changed path
in the top-down manner, reorganize the structure and then Join everything in the
bottom-up manner.

\subsection{Choose}

This operation for given cluster with full information (all clusters above it
are splitted -- efficiently this is a root cluster) selects one of its child
clusters. It gets reference to the cluster and its children and returns
reference to one of them. It is used internally by the {\I Search} operation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Top Trees operations}

These are the only operations which could user use to manipulate with the Top
Trees structure. In addition to that user could access root clusters and read
informations from them.

\subsubsection{Handles}

Following operations are defined for pair of vertices of the underlying forest,
but the Top Trees structure operates on (generalized) edges. We need to map
these vertices to clusters.

We want to choose clusters whose in some way represent operations with
vertices. Every cluster represents some path and for given vertex we want to
choose cluster which has this vertex in its path. Also we want that the chosen
cluster could be easily transformed around this vertex. This means that we want
cluster that has chosen vertex as its boundary vertex or common vertex
(if compress clusters).

To accomplish this mapping we define {\I handle} for each vertex of the
underlying forest in this way:

\begin{itemize}
\item Isolated vertex has no handle.
\item If the vertex is a leaf of the underlying tree the
handle for this vertex is the topmost compress (or base) cluster having this
vertex as one of its boundary vertices.
\item Root cluster is handle for its boundary vertices regardless of this vertex
degree in the underlying tree.
\item And finally if the vertex has degree at least two the compress cluster of
this vertex (compress cluster having this vertex as the common boundary vertex)
is the handle of this vertex.
\end{itemize}

One node could be handle for at most three vertices -- two as endpoints and one
as common boundary vertex. To mark handle of a vertex $v$ we will use notation
$N_v$.

With handles we could transform operations with vertices into operations with
clusters.

\subsection{Expose}

This is the most basic operation (which is used internally by other
operations). Calling $\expose{u,v}$ will result in several changes in the Top
Trees structure depending on the positions of vertices $u$ and $v$.

Implementation of the expose slightly differs in the first and the second
implementation (first implementation uses splays and splices and the second one
does expose through several splits and joins), but the result cluster is the
same cluster (but with possibly different decomposition to subclusters).

% TODO: move into implementation chapter

In the first implementation expose operation has two parts: soft and hard
expose. Soft expose is used internally by others operations, hard expose is used
only in Expose itself.
In the second
implementation with topology trees the expose is implemented by series of cuts
and joins and this is described in the \Cref{chap:TopologyTrees} of this thesis. We
describe here the soft and hard expose from the first implementation as they
operate directly with the top trees clusters.

\subsubsection{Soft expose}

% TODO: is definition of components necessary?
If given vertices are in different components (they are not connected by a path)
both the handles of $u$ and $v$ are brought to the roots of corresponding top
trees using series of local changes in the top trees (similarly if $u=v$).

When they are in the same component (they are connected by a path) firstly the
handle of $u$ is brought to the root of corresponding top tree. If the current
root cluster is also handle of $v$ we are done, otherwise the handle of $v$ is
brought as close to the root as possible (but not replacing the handle of $u$ as
root).

\todo{Picture of situation after soft expose}

In the most general case there will be one compress cluster (with one of the
exposed vertices as middle common vertex) as root of the corresponding top tree
with another compress cluster (with the second exposed vertice) as child. These
compress clusters would limit the path from both sides and finally between them
as a child of the second one compress cluster there will be cluster representing
the $u,v$-path. To expose it we will need the hard expose operation.

\subsubsection{Hard expose}

Ideal situation is when $u$ and $v$ are endpoints of the root cluster, it is
possible when both of them have degree one or when all others clusters incident
to the root clusters are raked onto the root cluster.

But in general root cluster could represent some path $(x,y)$ with path $(u,v)$
as subpath. In this case we need to temporarily convert ends of this path (paths
$(x,u)$ and $(v,y)$) into rake clusters so the compress tree would represent the
path $(u,v)$ with these ends raked onto this path.

% TODO: "at most two compress clusters" this is true only for model with foster children
As we described above there could be at most two compress clusters above our
wanted cluster. We could convert them to rake clusters (before that we may need
to swap their children to ensure that the final rake cluster will have the same
endpoints as our wanted cluster).

% TODO: defined "normal state"
Before any other operation we have to return all converted clusters back into
their normal state (change rake clusters back to compress clusters), otherwise
after several hard exposes we would split all paths into short segments.

% end TODO

\subsection{Cut}

Operation $\cut{u,v}$ deletes edge between vertices $u$ and $v$ and reorganizes
the Top Trees structure to reflect this change. We assume that $u\ne v$ and
there exists edge $(u,v)$. Implementation of the Cut operation in the second
implementation would be described in the next chapter of this thesis, now we
describe the Cut operation from the first implementation.
% TODO: chapter link

Firstly the structure internally performs {\I soft expose} on $u,v$ to bring
their handles to the top of corresponding top tree. In this situation the
handle of $u$ will be the root cluster and the handle of $v$ will be child of
the root cluster.

\todo{Picture of cut}
We have to destroy the base node representing $(u,v)$ and remove connection
between these two handles. After that we have to reorganize clusters to ensure
all clusters have both children. This operation results in two top trees, one
with handle of~$u$ as root cluster and second with handle of~$v$ as root
cluster.

\subsection{Link}

Calling $\link{u,v}$ on two disconnected vertices joins them by new edge $(u,v)$.
Implementation of the Link operation in the second implementation would be
described in the next chapter of this thesis, now we describe the Link operation
from the first implemenation.
% TODO: chapter link

Link is similar to the cut operation but in the opposite way. Firstly we start
by {\I exposing} (bringing to root) handles of $u$ and $v$.

\todo{Picture of link}
Then we create new base cluster representing edge $(u,v)$ and connect it as
child of the root cluster of the first top tree (the former child must be
moved deeper in the top tree). And lastly we connect this top tree as child of
the root cluster of the second top tree (again the former child must be moved
away).

\subsection{Search}

When defined the {\I Choose} user function this operation could be used to find
and return specific base cluster.

\todo{Example of search.}
