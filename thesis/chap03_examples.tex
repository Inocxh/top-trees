\chapter{Examples of problems and user functions}
\label{chap:Problems}

In this section there is a list of several problems which could be solved by
Top Trees with small time complexity.

\section{Finding distance between two vertices}

This problem was originally solved in {\I A Data Structure for Dynamic Trees}
\cite{DSforDynamicTrees} by Sleator and Tarjan in 1983 and then it was adapted
for Top Trees by Alstrup, Holm, Lichtenberg and Thorup in \cite{TopTrees}.

{\bf Theorem:} Lets have dynamic collection of weighted trees with link and cut
operations. We could find length of the path between any two vertices (or find
that they are not connected) in $\O(\log N)$ time.

\medskip\noindent
{\bf Proof:} We will maintain length of the cluster path in every cluster.

\begin{itemize}

\item $\Create$ creates cluster length equivalent to the length of the
underlying edge.

\item $\Join$ of clusters $C_1$ and $C_2$ into $C$ depends on the type of the $C$:
	\begin{itemize}
	\item If $C$ is a compress cluster of $C_1$ and $C_2$:
	Set length of the $C$'s path as sum of the lengths of $C_1$ and $C_2$.
	\item If $C$ is a rake cluster and $C_1$ is raked onto $C_2$:
	Set length of the $C$'s path as length of the $C_2$'s path (and vice
	versa if $C_2$ is raked onto $C_1$).
	\end{itemize}

\item $\Split$ and $\Destroy$ does nothing.

\end{itemize}

After that we could easily get length of the $(u,v)$-path by calling
$\Expose(u,v)$ and reading length from this cluster. Because operations
in user functions are in constant time and \Expose{} takes $\O(\log N)$
operations, we could answer on any such question in $\O(\log N)$ time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Maximum edge weight between given vertices with interval update}
\label{sec:maximum_edge_weight}

Similarly to the previous problem this problem was originally solved in
\cite{DSforDynamicTrees} and then it was adapted for Top Trees  in
\cite{TopTrees}.

{\bf Theorem:} Let's have dynamic collection of weighted trees with operation of linking,
cutting, updating edge weight and updating edge weights on given path. We could
find maximum edge weight between any two vertices (or find that they are not
connected) in $\O(\log N)$ time.

\medskip\noindent
{\bf Proof:} We can maintain $w_{max}$ in each cluster as maximum weight on this
cluster's path and $w_{extra}$ as weight added to each edge on this path.

\begin{itemize}

\item $\Create$ creates cluster with $w_{max}=w(e)$ where $e$ is the edge for
which is this cluster created. There is no extra weight yet, so $w_{extra}=0$.

\item $\Join$ of clusters $C_1$ and $C_2$ into $C$ depends on the type of the $C$:
	\begin{itemize}
	\item If $C$ is a compress cluster of $C_1$ and $C_2$:
	Set $w_{max}$ as maximum of $w_{max}$ from clusters $C_1$ and $C_2$.
	There is no extra weight, so $w_{extra}=0$.
	\item If $C$ is a rake cluster and $C_1$ is raked onto $C_2$:
	Copy $w_{max}$ from the $C_2$. There is no extra weigh, so $w_{extra}=0$.
	\end{itemize}

\item $\Split$ have to distribute $w_{extra}$ to the children. For $C_1, C_2$,  children
of splitted $C$ will operations depend on the type of the $C$:
	\begin{itemize}
	\item If $C$ is a compress cluster of $C_1$ and $C_2$:
		\begin{itemize}[$\circ$]
		\item $w_{extra}(C_i)=w_{extra}(C_i)+w_{extra}(C)$ for $i\in{1,2}$
		\item $w_{max}(C_i)=w_{max}(C_i)+w_{extra}(C)$ for $i\in{1,2}$
		\end{itemize}
	\item If $C$ is a rake cluster and $C_1$ is raked onto $C_2$:
	Apply above operation only for $C_2$ (and vice versa only for $C_1$ if $C_2$
	is raked onto $C_1$).
	\end{itemize}


\item $\Destroy$ sets weight of the underlying edge: $w(e)=w_{max}+w_{extra}$.

\end{itemize}

Then we could just call $\Expose(u,v)$ and read $w_{max}$ or add both to
$w_{extra}$ and $w_{max}$ of the root cluster representing the $(u,v)$-path.
Everything in time complexity of an {\sc Expose} operation, which is $\O(\log
N)$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Diameter and center of the trees}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Edge 2-connectivity}
\label{sec:edge_2_connectivity}

This is an example of more complex problem, where is the Top tree structure used
as only part of the whole algorithm. It was introduced by Holm, Lichtenberg and
Thorup in 2001 in \cite{PolylogarithmicAlgorithmsForConnectivity}, where is an
complete elaboration of the problem. There I will only recall some basic
principles, most of this section is a simplified citation from the
\cite{PolylogarithmicAlgorithmsForConnectivity}.

\noindent
{\bf Theorem:} Problem of 2-edge connectivity on dynamically updated graph with
$N$ edges could be solved in $\O(\log^4 N)$ per operation -- addition or
deletion of an edge and test if given vertices are 2-edge connected.

\subsubsection{Basic principle}

We will maintain a spanning forest $F$ of graph $G$ and we will say, that tree
edge $e$ is {\I covered} by nontree edge $v,w$ if $e \in v\dots w$ (if there is
a tree path from $v$ to $w$ and $e$ is on this path).

Frederickson showed that two vertices $x$ and $y$ are 2-edge connected if and
only if they are connected in $F$ and all edges in path $x\dots y$ are covered.

So we will maintain a spanning forest $F$ together with a set $C$ with covering
edges for each non-bridge edge in $F$. Two vertices are 2-edge connected in $G$
if and only if they are 2-edge connected in $F\cup C$.

During updates, when we will delete an edge from $F$ we will need to find an
replacement in $C$. And for every deleted edge from $C$ we may need to add
several replacement edges to add into $C$. By carefully choosing replacement
edges we will be able to amortize the time to meet $\O(\log^4 N)$ per operation.

\subsubsection{Details}

Algorithm associate with every nontree edge a level (number $< \log N$), each
edge starts with level 0 and level may be increased. And for each $i$ we will
define a graph $G_i$ as graph induces by only edges of level at least $i$
together with the $F$.

For each tree edge $e \in F$ we will maintain a cover level as maximum level of
nontree edge covering it (thus maximum level for which $e$ is in 2-edge
connected component).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Vertex 2-connectivity}

In time $\O(\log^5 N)$ by Holm, Lichtenberg and Thorup 2001 in \cite{PolylogarithmicAlgorithmsForConnectivity}

\todo{Do some study.}
