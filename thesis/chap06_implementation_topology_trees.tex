\chapter{Implementation of Top Trees using Topology Trees}
\label{chap:ImplementationTopology}

This implementation is based on the article {\I Maintaining Information in
Fully-Dynamic Trees with Top Trees} \cite{TopTrees} by Alstrup, Holm,
Lichtenberg and Thorup. It builds Top trees structure on the base of topology
trees introduced in the \Cref{chap:TopologyTrees}. The update process of
topology trees and some basic overview of top clusters mapping was discussed in
that chapter, there we will introduce some details of joining, splitting and the
\Expose{} operation (\Link{} and \Cut{} operations have been described in the
mentioned chapter).

\section{Mapping top trees clusters}

Usage of Topology trees as backend for Top trees was described by Alstrup, Holm,
Lichtenberg and Thorup in \cite{TopTrees}. They described the need of
ternarization and how to transform operations with the topology clusters to
\Split{} and \Join{} functions used in the Top trees structure.

Outgoing edges acts differently in topology clusters and top trees clusters --
in topology clusters outgoing edges are not parts of topology clusters, but
top trees clusters are based on these edges. Even that this is a major
difference the mapping could be done quite easily.

But before mapping we have to deal with fake subvertices and subvertice edges
added by ternarization.

\subsection{Subvertices and subvertice edges from the Top trees perspective}

During ternarization in the \Cref{chap:TopologyTrees} we added additional
subvertices and subvertice edges into into the graph. That is needed by topology
trees but it may be problem for the top trees operations.

Firstly how to deal with subvertices: When performing top trees \Join{} or
\Split{} and joined cluster has subvertex as its endpoint, we use the superior
vertex of this endpoint instead of the original endpoint when passing endpoint
to the \Join/\Split{} user function. From the user's points of view all
subvertices are represented by the original superior vertex.

And how to deal with subvertice edges? Just ignore them -- there are no top
clusters associated with them. When joining topology cluster with subvertice
edge and two children, we just rake these children ignoring the edge.

\subsection{Associated top clusters}

With each topology cluster may be associated at most three top clusters:
\begin{itemize}
\item {\I Edge cluster} -- when there is an normal edge inside the topology cluster.
\item {\I Combined edge cluster} -- joined {\I edge cluster} and cluster from
the first child (when the first child has its own top cluster).
\item {\I Top cluster} for the whole topology cluster (joining {\I combined edge
cluster} and cluster from the second child if there is any).
\end{itemize}

If topology cluster (or recursive its children) contains at least one normal
edge we call it {\I topology top cluster} (because it has associated top
cluster). Otherwise we will call it {\I empty topology cluster}. Originally all
vertices of the original tree are empty topology clusters and by joining them we
create topology top clusters.


\section{Joins and Splits}

$\Join$ and \Split{} (and \Create{} and \Destroy{} for base clusters) are user
defined functions that are called on top clusters with defined endpoints. We
cannot call them directly on topology clusters, so we need to split topology
clusters to associated top clusters and call user defined function on these top
clusters.

The external view of the topology clusters during splitting and joining is
similar as in the first implementation -- when operating on some topology
cluster we have to firstly ensure that this cluster and all of its parents are
splitted. Splitting is done recursively in the top-down manner and all splitted
clusters have to be joined after completing all operations in the bottom-up
manner. This is done by logging all splitted topology clusters into some list
and joining all of them after completing current operation.

\subsection{Joining}

We will recall that if the topology cluster $C$ is not base cluster on the
lowest level it could have one or two children (mark them as $C_1$ and $C_2$).
When joining the $C$ we have to do these operations:
\begin{enumerate}

\item If $C$ has only one child $\rightarrow$ Just copy $C_1$'s {\I top cluster}
(with endpoints) into the $C$'s {\I top cluster} and end.

\item If there is a normal edge between $C_1$ and $C_2$ $\rightarrow$ \Create{}
new {\I edge cluster} from this edge (otherwise initialize dummy one).

\item If the $C_1$ is a topology top cluster:
\begin{itemize}
\item If we created an {\I edge cluster} $\rightarrow$ \Join{} $C_1$'s {\I top
cluster} with the {\I edge cluster} into {\I combined egde cluster} (depending
on $C_1$'s shape set new cluster's endpoints as rake or compress cluster).
\item Otherwise copy $C_1$'s {\I top cluster} into {\I combined edge cluster}
(with updating endpoints).
\end{itemize}
Otherwise just copy {\I edge cluster} into {\I combined edge cluster}.

\item If the $C_2$ is a topology top cluster:
\begin{itemize}
\item If there is valid {\I combined edge cluster} (if $C_1$ is a topology top
cluster or there is a normal edge) $\rightarrow$ \Join{} $C_2$'s {\I top cluster}
with the {\I combined edge cluster} into $C$'s {\I top cluster} (depending
on $C_2$'s shape set new cluster's endpoints as rake or compress cluster).
\item Otherwise copy $C_2$'s {\I top cluster} into $C$'s {\I top cluster}.
\end{itemize}
Otherwise just copy {\I combined edge cluster} into $C$'s {\I top cluster}.

\end{enumerate}

We have done at most two calls to the \Join{} user function and one to the
\Create{} user function.

\subsection{Splitting}

Split procedure is opposite to the join procedure. Endpoints of all top clusters
are correctly set by the join procedure so we have to only do \Split{} and
\Destroy{} operations in the opposite way.

If there is a normal edge in the topology cluster we firstly \Split{} $C$'s
{\I top cluster} into {\I combined edge cluster} and $C_2$'s {\I top cluster}
and then \Split{} {\I combined edge cluster} into {\I edge cluster} and $C_1$'s
{\I top cluster}. Finally just \Destroy{} the {\I edge cluster}.

When there is a subvertice edge just Split $C$'s {\I top cluster} into children
{\I top clusters}. If some of the children is not a topology top cluster we just
do copy instead of \Split{} (like in the join procedure).

We have done at most two calls to the \Split{} user function and one to the
\Create{} user function.


\section{Expose}

The mechanism of the $\Expose(u,v)$ is slightly tricky. Basic idea of the
\Expose{} in the Top trees structure based on topology trees is to leave the
topology trees intact. We only need to split some topology clusters and then
take their inner top clusters and join them into a new structure.

This procedure was basically described by Alstrup et al. in \cite{TopTrees} but
without any details. Here I describe it will all necessary details.

We split all topology clusters in the paths from both exposed vertices to the
root of corresponding topology tree, which gave us $\O(\log N)$ top clusters
splitted around this path (because of the maximal height of a topology tree for
$N$ vertices).

Then we join all these top clusters to construct {\I auxiliary top tree} such
that the root cluster of this auxiliary top tree would be a compress cluster
with two given vertices as its endpoints (and all other clusters raked on its
path).

After finishing \Expose{} we serve the root cluster to the user and he could do
modifications on this root cluster. When it is over we split the auxiliary top
tree, which distributes information from the modified root cluster into splitted
clusters in the original topology tree. Finally we join all splitted clusters
in the topology tree and the operation is finished.

\subsection{Splitting}

Firstly we start will recursive splitting from both given vertices -- better
said from base topology clusters that contains these vertices. We need to split
all clusters that contain them but not as {\I external vertices} and to save
these splitted vertices into {\I chains} whose we will join in the next step.

We have to make clear that {\I boundary vertices} (or endpoints) that we defined
for top trees may be different that {\I external vertices}. More precisely
external vertices are subset of boundary vertices. We defined that each top
cluster has two boundary vertices because we defined top clusters as generalized
edges. But external vertices are only those boundary vertices that are connected
to others clusters.

With definition of external vertices the splitting part is straightforward --
for each cluster (starting from given vertex's base cluster) we check that given
vertex is external vertex (by checking outgoing edges) and if no we split this
cluster.

Notice that all clusters above the first splitted clusters will be splitted too,
because once the vertex stops be external it will never be external again. To
have the full coverage of the tree we have to add the last not splitted cluster
to the chain too (it will be the first cluster in the chain).

Splitted cluster is divided (by at most two call to the \Split{} user function
and one to the \Destroy{} user function) into at most two topology clusters (one
from which we climbed up and second as its sibling) and one edge.

If there is sibling cluster, this sibling has its top cluster and there is a
normal edge, we \Create{} top cluster for this edge, \Join{} this top cluster
with sibling's top cluster (according to previous situation of both siblings we
join them as rake or compress cluster) and then we add them into chain of top
clusters for the next operation. If there is only edge or only sibling's top
cluster (when there is only a subvertice edge) we just add it into chain
directly without joining.

We only need to care not to add sibling that is on the second vertex's path.
For the second vertex the only difference would be that we will stop this
process when we reach already splitted cluster (otherwise we would add some
clusters twice). Splitted clusters for the second vertex will be saved into
separate chain.

\subsubsection{Example of splitted chains}

We will take topology tree from the figure \ref{fig:topology_tree_construction}
(page \pageref{fig:topology_tree_construction}) and let us \Expose(b,f). We will
start splitting clusters from base clusters containing these vertices as you
can see on the figure \ref{fig:chain_clusters_example}.

Firstly we split all clusters above vertices $b$ and $f$. Then starting from the
vertex $b$ we continue up to the moment, when $b$ stops be an external vertex
-- it is in the cluster $c$-$e_2$ where we add the previous cluster ($c$-$b$)
into the chain. Also we should add our sibling $e_1$-$e_2$, but this cluster is
splitted (because it is on the path from $f$ to the root) so we add only the
edge cluster $b$-$e_1$.

Continuing above we add sibling cluster $g$-$h$ combined with edge (so we will
push cluster $e_2$-$h$ into the chain) and that is all for the first vertex.
For the second vertex we continue up until reaching cluster $e_1$-$e_2$, where
$f$ stops be an external vertex. We add previous cluster $e_2$-$f$ and sibling
$e_1$-$d$ to the second chain (notice that we ignore subvertice edge because it
is not a cluster). Above this cluster we hit the path processed by the first run
and thus we end.

\begin{figure}[h]
\centering
\asyinclude{pic/chap06_expose_splitting.asy}
\caption{Splitting from vertices b and f. Marked clusters will be added into
chains -- notice that they cover all vertices of the underlying tree and with
connecting edges they cover all edges too.}
\label{fig:chain_clusters_example}
\end{figure}

We ended with two chains of clusters: [$c$-$b$; $b$-$e_1$; $e_2$-$h$] and
[$f$-$e_2$; $e_1$-$d$], that have to be joined together. Subvertices
of the same vertex acts from this point of view as the same vertex and therefore
we may act like all occurrences of the $e_1$ or $e_2$ are $e$ (from this point
we will not act with topology tree structure and ternarization is not needed).

\subsection{Chain joining}

During splitting we saved splitted clusters along the paths from both given
vertices and we saved those splitted vertices into two chains. We can reverse
one chain and append it to the other one to make complete chain.

This chain starts by cluster that have first given vertex as it's external vertex and
similarly ends by cluster that have the second given vertex as it's external
vertex. In the chain there are clusters representing path between these two
external vertices and clusters that represent rest of the tree. We need to rake
non-path clusters onto path clusters and then compress all path clusters into
one.

From the mechanism of the construction there cannot be any long branch from the
path (we added only one neighbour cluster per level during splitting). Therefore
we could imagine clusters in the chain as ``domino bricks'' where some of them
have to be turned (raked) to make the chain continuous.

Our task is to construct sequence of clusters
$(v_0,v_1),(v_1,v_2),\dots,(v_{n-1},v_n)$ where $u=v_0$ and $v=v_n$. The first
problem is that clusters (bricks in the chain) may be in reversed, but this is
easy to fix. The second problem it that there may be places where it looks like
$(v_{i-1}, v_i),(v_i, x),(v_i,v_{i+1})$. We need to rake these clusters to one
of their neighbours.

We will be going through the chain from one side and doing repair when we could
not connect current cluster.

\begin{figure}[h]
\centering
\asyinclude{pic/chap06_domino.asy}
\caption{Clusters chain between given vertices $a-e$ displayed as ``domino bricks''
with two rakes operations. In the first and second row there are highlighted
clusters that cannot be joined to the previous cluster and therefore some raking
must be done -- see the following algorithm.}
\end{figure}

After that we just need to compress all clusters in the chain to obtain the
final root cluster with endpoints $(u,v)$. It represents the $(u,v)$ path with
all others parts of the tree raked.

The whole algorithm would be:
\begin{enumerate}

\item Start by choosing $x=u$.

\item Rake all clusters that needs to be raked. Go through all clusters:
\begin{itemize}
\item {\I If one of the current cluster's endpoints is $x$:} This cluster
could be connected after the previous in the chain. Leave this cluster intact
and set $x$ as its opposite endpoint.
\item {\I Otherwise:} We cannot join this cluster to the previous and we need to
do some raking. There may be two options depending on the endpoint of neighbour
clusters (one of them must occur):
\begin{enumerate}

	\item {\I The previous cluster in the chain has common vertex (second
	row in the figure with domino bricks):} The previous cluster is a~branch
	in the wrong direction and thus it has to be raked.

	We remove the previous and the current clusters from the chain. Then we
	construct a new top cluster as a rake \Join{} of the previous cluster
	onto the current one. Finally we add this new top cluster into the chain
	and we set $x$ as the current cluster's second endpoint. Then we advance
	to the following cluster.

	\item {\I The following cluster in the chain has common vertex (first
	row in the figure with domino bricks):} Current cluster is a~branch and
	it has to be raked on the following cluster.

	We remove current cluster and the following one from the chain and then
	we construct and add a new top cluster as a rake \Join{} of the current
	cluster onto the following one. We left $x$ intact (because we still
	does not found cluster that could be joined after the previous one) and
	advance to the newly inserted cluster.

\end{enumerate}

\end{itemize}

\item After raking inner clusters in the chain check that we end with $x=v$. If
no rake the last cluster onto the previous one until $x=v$.

\item Compress \Join{} any two neighbour clusters in the chain until there is
only one cluster.

\end{enumerate}

The last cluster is returned to the user. Because paths from both given vertices
to the root cluster has length at most $\O(\log N)$ there were at most $\O(\log
N)$ clusters. Thus constructing of chains and their joining takes $\O(\log N)$
calls to the \Join{} user function.

Now the structure is in a degraded form and before any other operation it must
be restored.

\subsection{Restore}

Restore is called manually by the user or automatically by all others
operations. If the structure was modified by the \Expose{} there is a topology
tree in the right shape, but with splitted clusters. And also there is an
auxiliary top tree which could contain modified information that should be
distributed into original clusters.

Firstly we need to \Split{} all the clusters in the auxiliary top tree (there
is at most $\O(\log N)$ clusters). Clusters on the last level of the auxiliary
top tree distributes information to the clusters in the original tree.

Now we can delete the auxiliary top tree and then join all the splitted clusters
in the original tree. Because the initial splitting takes $\O(\log N)$ calls to
the \Split{} user function the joining would take the same amount of calls to
the \Join{} user function.

\subsection{Keeping original clusters during \Expose}

Because the original shape of the underlying topology tree remains intact during
the \Expose{} operation we may use it for our benefit. From the user's point of
view we \Split{} some clusters, then we build from them a new top tree and
finally we destroy this new top tree and \Join{} again the same clusters as were
before.

In some use cases there are a lot of informations in the clusters used for
structural changes in the underlying clusters -- for example in the 2-edge
connectivity that we will use as one of our experiments. In that cases if may be
good to turn off some expensive updates during \Join/\Split{} and to turn them
on after the top tree is returned into its original shape.

For that behaviour we need to remember the original values somewhere. User may do this
on it's own (for example by saving this information in edges), but there is an
better approach. Because our interface for all user functions pass them pointers
to the clusters (and the data is stored inside them) we may keep these original
clusters intact after the \Split{} and then pass them to the \Join{} (instead of
newly created empty clusters). We will use this functionality on our experiment
with the 2-edge connectivity.
